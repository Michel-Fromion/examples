/* Generated by YAKINDU Statechart Tools code generator. */

package traffic.light.tests;

import static org.mockito.Mockito.*;
import static org.mockito.Matchers.*;
import static org.hamcrest.CoreMatchers.*;
import traffic.light.trafficlightctrl.ITrafficLightCtrlStatemachine.*;
import org.mockito.ArgumentCaptor;
import static org.mockito.ArgumentCaptor.forClass;		
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.junit.*;
import static org.junit.Assert.*;
import traffic.light.trafficlightctrl.TrafficLightCtrlStatemachine;
import traffic.light.trafficlightctrl.TrafficLightCtrlStatemachine.State;	
import traffic.light.VirtualTimer;
import traffic.light.VirtualTimer.VirtualTimeTask;

/**
 * Unit TestCase for TrafficLightCtrl
 */
@SuppressWarnings("all")
public class TrafficLightTest {
	SCInterfaceOperationCallback defaultMock;
	
	private TrafficLightCtrlStatemachine statemachine;	
	private VirtualTimer timer;
	
	
	
	@Before
	public void trafficLightTest_setUp() {
		statemachine = new TrafficLightCtrlStatemachine();
		timer = new VirtualTimer();
		timer.schedulePeriodicalTask(new VirtualTimeTask() {
			@Override
			public void run() {
				statemachine.runCycle();
			}
		}, 250, 250);
		statemachine.setTimer(timer);
		statemachine.init();
		defaultMock = mock(SCInterfaceOperationCallback.class);
		statemachine.getSCInterface().setSCInterfaceOperationCallback(defaultMock);
	}

	@After
	public void trafficLightTest_tearDown() {
		statemachine.getSCInterface().setSCInterfaceOperationCallback(null);
		statemachine = null;
		timer = null;
	}
	
	@Test
	public void testInitialState() {
		statemachine.enter();
		assertTrue(statemachine.isStateActive(State.main_region_off));
		assertTrue(statemachine.isStateActive(State.main_region_off_r1_YellowOn));
		assertFlags(false,true,false,false,false,true);
	}
	@Test
	public void testYellowOffAfter500ms() {
		statemachine.enter();
		timer.timeLeap(500);
		assertTrue(statemachine.isStateActive(State.main_region_off_r1_YellowOff));
		assertFlags(false,false,false,false,false,false);
		verify(defaultMock, atLeastOnce()).synchronize();
		 
	}
	@Test
	public void testYellowOnAfter1s() {
		statemachine.enter();
		timer.timeLeap(1000);
		assertTrue(statemachine.isStateActive(State.main_region_off_r1_YellowOn));
		assertFlags(false,true,false,false,false,true);
		verify(defaultMock, atLeastOnce()).synchronize();
		 
	}
	@Test
	public void testSafeState() {
		statemachine.enter();
		enterSafeState();
		assertTrue(statemachine.isStateActive(State.main_region_on));
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_Safe));
		assertFlags(true,false,false,true,false,false);
	}
	@Test
	public void testStreetPrepare() {
		statemachine.enter();
		enterSafeState();
		timer.timeLeap(10000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_StreetPrepare));
		assertFlags(true,true,false,true,false,false);
		verify(defaultMock, atLeastOnce()).synchronize();
		 
	}
	@Test
	public void testStreetGreen() {
		statemachine.enter();
		testStreetPrepare();
		timer.timeLeap(2000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_StreetGreen));
		assertFlags(false,false,true,true,false,false);
	}
	@Test
	public void testPedWaitOn() {
		statemachine.enter();
		testStreetGreen();
		statemachine.raisePedestrianRequest();
		statemachine.runCycle();
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_PedWaiting_r1_waitOn));
		assertFlags(false,false,true,true,false,true);
	}
	@Test
	public void testPedWaitOff() {
		statemachine.enter();
		testPedWaitOn();
		timer.timeLeap(500);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_PedWaiting_r1_waitOff));
		assertFlags(false,false,true,true,false,false);
	}
	@Test
	public void testStreetAttention() {
		statemachine.enter();
		testPedWaitOn();
		timer.timeLeap(7000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_StreetAttention));
		assertFlags(false,true,false,true,false,false);
	}
	@Test
	public void testStreetRed() {
		statemachine.enter();
		testStreetAttention();
		timer.timeLeap(2000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_StreetRed));
		assertFlags(true,false,false,true,false,false);
	}
	@Test
	public void testPedestrianGreen() {
		statemachine.enter();
		testStreetRed();
		timer.timeLeap(2000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_PedestrianGreen));
		assertFlags(true,false,false,false,true,false);
	}
	@Test
	public void testPedestrianRed() {
		statemachine.enter();
		testPedestrianGreen();
		timer.timeLeap(7000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_PedestrianRed));
		assertFlags(true,false,false,true,false,false);
	}
	@Test
	public void testReturnToStreetPrepare() {
		statemachine.enter();
		testPedestrianRed();
		timer.timeLeap(5000);
		assertTrue(statemachine.isStateActive(State.main_region_on_r1_StreetPrepare));
		assertFlags(true,true,false,true,false,false);
	}
	@Test
	public void testReturnToOffState() {
		testStreetAttention();
		statemachine.raiseOnOff();
		statemachine.runCycle();
		assertTrue(statemachine.isStateActive(State.main_region_off));
		assertTrue(statemachine.isStateActive(State.main_region_off_r1_YellowOn));
		assertFlags(false,true,false,false,false,true);
	}
	public void enterSafeState() {
		statemachine.raiseOnOff();
		statemachine.runCycle();
	}
	public void assertFlags(boolean trafficRed, boolean trafficYellow, boolean trafficGreen, boolean pedRed, boolean pedGreen, boolean pedRequest) {
		assertTrue(statemachine.getSCITrafficLight().getRed() == trafficRed);
		assertTrue(statemachine.getSCITrafficLight().getYellow() == trafficYellow);
		assertTrue(statemachine.getSCITrafficLight().getGreen() == trafficGreen);
		assertTrue(statemachine.getSCIPedestrian().getRed() == pedRed);
		assertTrue(statemachine.getSCIPedestrian().getGreen() == pedGreen);
		assertTrue(statemachine.getSCIPedestrian().getRequest() == pedRequest);
	}
}
