<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Light Switch Example Series</title>
<link href="../css/style.css" rel="stylesheet">
</head>
<body class="body-container">

  <h1>Light Switch Example Series</h1>

  <p>This is a series of examples demonstrating multiple features of YAKINDU
    SCT. With each iteration, more features are shown. This example is a good
    starting point to dive into SCT headfirst.</p>

  <div>
    <h2>The First Iteration: A Simple Switch</h2>

    <p>
      This is the most basic way to model a light switch. When the <em>operate</em>
      event is raised, the light switch changes between <strong>On</strong> and
      <strong>Off</strong> states.
    </p>

    <p>
      <img class="standard-image" alt="First iteration without any features"
        src="images/01_light_switch.png" />
    </p>

    <p>
      This statechart can be simulated, but the <em>internal</em> interface does
      not allow to use it with code in a useful way.
    </p>
  </div>

  <div>
    <h2>The Second Iteration: Introducing Interfaces</h2>

    <p>
      To use the statechart from code, you need an interface to it. This version
      has an interface named <em>user</em>, so <em>user.operate</em> can be
      raised. YAKINDU SCT does not generate methods to interact with objects
      belonging to the <em>internal</em> interface.
    </p>

    <p>
      <img class="standard-image" alt="Second iteration, introducing interfaces"
        src="images/02_light_switch.png" />
    </p>
  </div>

  <div>
    <h2>The Third Iteration: Introducing Variables</h2>

    <p>
      While the classic theory of <a
        href="https://en.wikipedia.org/wiki/Input/output_automaton">input/output
        automata</a> is only aware of events, Harel's statecharts and YAKINDU SCT
      have many more features – including variables.
    </p>

    <p>With these, you can model a dimmer.</p>

    <p>
      <img class="standard-image" alt="Third iteration, introducing variables"
        src="images/03_light_switch_dimmer.png" />
    </p>

    <p>
      When the user operates the <strong>On</strong> button for the first time,
      the light is switched on with the brightness level set to 1. On further
      operations of the button, the brightness is incremented by 1 up to a value
      of 10. Operating the <strong>Off</strong> button switches off the light.
      The dimmer will not remember the last brightness level and will restart
      with a brightness of 1 when the <strong>On</strong> button is pressed. The
      example shows that the variable is manipulated by actions as well as used
      as a guard in transitions.
    </p>
  </div>

  <div>
    <h2>The Fourth Iteration: Introducing Composite States</h2>

    <p>
      Composite states are another feature of YAKINDU SCT. With these, you can
      create a state that contains one or more other states. The main advantages
      are a better clarity of the statechart and the possibility to create exit
      transitions from everywhere in the composite state. Without the composite
      state, you would need one more transition: Both states in the <strong>MotionSense</strong>
      composite state would have a transition with <em>user.on_switch</em> to
      the <strong>Dimm</strong> state in the <strong>Manual</strong> composite
      state.
    </p>

    <p>
      <img class="standard-image" alt="Fourth iteration, using composite states"
        src="images/04_light_switch_motion.png" />
    </p>
  </div>

  <div>
    <h2>The Fifth Iteration: History States</h2>

    <p>
      This example should clarify how history states work, what they do, and
      especially what they don't do. We introduce another mode, twilight /
      luminosity control, for our light switch, which starts to change into a
      full light control module. The statechart now contains three <em>shallow
        history</em> states:
    </p>

    <p>
      <img class="standard-image"
        alt="Fifth iteration, including history states"
        src="images/05_light_switch_twilight.png" />
    </p>

    <p>
      So, what do these history states do? There is one in <strong>Twilight</strong>,
      one in <strong>MotionSense</strong>, and one in the <strong>Automatic</strong>
      composite state the former two are nested in.
    </p>

    <p>A shallow history state, contained in a composite state with a set of
      possible states inside that composite state, remembers which of these
      states was last active when that composite state is left.</p>

    <p>
      The one in <strong>Automatic</strong> remembers whether <strong>Twilight</strong>
      or <strong>MotionSense</strong> was active when <strong>Automatic</strong>
      was left, but it doesn't remember which state was active within the active
      one of these two. On re-entry, the history state would activate either <strong>Twilight</strong>
      or <strong>MotionSense</strong>, but these would start on their respective
      entry states. This is why there is a history state in them as well.
    </p>

    <p>
      If you have worked with history states before, you might now be inclined
      to say "A deep history state would have been the correct thing here." You
      would only be partially right – on first glance, yes. A deep history state
      remembers the active state in its own region and everything that was
      active inside of this state, and so on, down to the lowest level. We might
      spare the two shallow history states in <strong>Twilight</strong> and <strong>MotionSense</strong>.
      But this would not act in the same way – a history state is activated only
      when its containing region is actually left. Using one deep history state
      would not allow to remember the active state in <strong>MotionSense</strong>
      when switching to <strong>Twilight</strong>, and vice versa. The deep
      history state would be activated only if we left the whole <strong>Automatic</strong>
      composite state – and we are not about to do that.
    </p>
  </div>

  <div>
    <h2>The Sixth And Last Iteration: Introducing Operations</h2>

    <p>This is the final version of the light switch, which has become a
      light computer. This version adds a presence simulation, which means it
      behaves as if a person operated the light switch although nobody in
      present. The motion detection and the twilight detection are left out for
      clarity.</p>

    <p>The presence simulation is activated on certain hours of the day
      (from 6 PM to midnight and from 6 AM to 10 AM). It switches the light on
      and off repeatedly in sensible, random intervals.</p>

    <p>
      To implement this functionality, we finally hit the limits of the
      statechart language: There is neither a function for random values, nor
      one to get the current date and time. However, YAKINDU SCT allows you to
      implement your own <em>operations</em> to overcome these limitations. An
      operation is called from the state machine itself, so you don't have to
      care about when and how they will be called. You can receive arguments
      from the state machine and return a value, exactly like a normal function
      or method call.
    </p>

    <p>
      <img class="standard-image" alt="Sixth iteration, introducing operations"
        src="images/06_light_switch_simulation.png" />
    </p>
  </div>

</body>
</html>